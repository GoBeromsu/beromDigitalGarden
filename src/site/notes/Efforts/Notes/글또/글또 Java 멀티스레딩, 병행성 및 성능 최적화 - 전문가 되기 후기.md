---
{"tags":["CS/언어/Java","글또"],"aliases":null,"link":null,"persona":null,"index":null,"date_created":"2024-04-12","date_modified":"2024-04-12","dg-publish":true,"permalink":"/efforts/notes//java/","dgPassFrontmatter":true,"noteIcon":"1","created":"2024-04-12T13:42:17.720+09:00","updated":"2024-04-12T14:18:09.379+09:00"}
---

# 글또 Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기 후기
![](https://i.imgur.com/2b2b5jL.png)

## Intro
학부생 때, 멀티 스레드 프로그래밍 과제를 하면서 순서 제어와 에러 해결에 어려움을 겪었던 경험이 떠올라 이 강의를 지원하게 되었습니다. 당시에는 밤을 새워가며 문제를 해결하고 운영체제에 대한 이해도를 쌓을 수 있었지만, 부족함을 느끼던 중 udemy 강의 이벤트를 접했습니다

우리가 일상적으로 사용하는 서비스 속에는 이미 멀티 스레드 기술이 당연히 적용되고 있을 텐데, 추상화된 개념 때문에 그 내면을 알지 못하는 부분이 분명 있을 거라는 생각이 들었습니다. 이번 강의를 통해 그런 숨겨진 부분들을 살펴보고, 멀티 스레드 프로그래밍을 바라보는 시야를 넓히고 싶었습니다.

아래는 강의 정리 내용의 일부입니다
## **락-프리(잠금 없는) 알고리즘, 데이터 구조 및 기법**

### 잠금 기반 프로그래밍의 문제점
잠금은 소프트웨어 및 하드웨어 개발에서 중요한 역할을 해왔으나, 다음과 같은 여러 문제점이 있습니다:

1. **데드락**: 복잡한 데드락 탐지 및 해결 로직 없이는 해결하기 어렵습니다.
2. **잠금 소유 시간**: 한 스레드가 잠금을 오랫동안 소유하면 다른 스레드가 느려질 수 있습니다.
3. **우선순위 역전**: 높은 우선순위의 스레드가 낮은 우선순위의 스레드가 소유한 잠금을 기다리는 경우 발생합니다.
4. **스레드 기아**: 잠금을 소유한 스레드가 예기치 않게 중단되면 다른 스레드가 무한히 대기하는 문제가 발생할 수 있습니다.
5. **성능 오버헤드**: 스레드간의 잠금 획득 경쟁은 성능 저하를 초래할 수 있습니다.

### 락-프리 프로그래밍의 필요성
- 원자적 연산을 활용하여 스레드 안전성을 제공하면서 잠금을 사용하지 않습니다.
- **원자적 연산**: 하드웨어 수준에서 지원되며, 데이터 경쟁 없이 안전하게 데이터를 읽고 쓸 수 있습니다.

### 자바의 원자적 클래스
- **패키지:** `java.util.concurrent.atomic`
- **핵심 클래스:** `AtomicInteger`, `AtomicLong`, `AtomicReference`
- **연산:** `AtomicInteger`의 `incrementAndGet`, `getAndIncrement`

### 락-프리 데이터 구조 예제
`AtomicReference`를 사용하여 락-프리 스택 구현:
```java
public class LockFreeStack<T> {
    private AtomicReference<Node<T>> head = new AtomicReference<>();

    public void push(T value) {
        Node<T> newHead = new Node<>(value);
        Node<T> oldHead;
        do {
            oldHead = head.get();
            newHead.next = oldHead;
        } while (!head.compareAndSet(oldHead, newHead));
    }
}
```

### 락-프리 프로그래밍에 대한 결론
잠금을 사용하는 것보다 훨씬 높은 성능을 제공하며, 특히 고성능 환경에서 유용합니다. 올바른 도구와 기법을 선택하는 것이 중요합니다.

## **I/O 작업을 위한 고성능 스레딩 모델**

### I/O 바운드 애플리케이션의 특성
- **주로 포함하는 작업**: 데이터 읽기/쓰기, 데이터베이스, 파일 시스템 또는 네트워크 통신과의 상호 작용.

### CPU와 메모리 구조
- **CPU**: 데이터를 매우 빠르게 처리하고 메모리에 직접 접근할 수 있습니다.
- **I/O 장치**: 외부 장치로 CPU가 직접 접근할 수 없습니다.

### 블로킹 대 논블로킹 I/O
- **블로킹 I/O**: 데이터가 준비될 때까지 스레드가 차단됩니다. 이는 CPU의 유휴 시간을 초래할 수 있습니다.
- **논블로킹 I/O**: 요청 후 즉시 제어권을 반환하여 CPU가 다른 작업을 계속할 수 있게 합니다. 데이터가 준비되면, 인터럽트가 발생하고 CPU는 결과를 처리합니다.

### 사례 연구
1. **웹 서버**: 수많은 동시 연결을 처리해야 하므로 논블로킹 I/O 모델이 적합합니다.
2. **데이터베이스 애플리케이션**: 논블로킹 I/O는 동시에 여러 데이터베이스 쿼리를 처리하면서 전반적인 성능을 향상시킬 수 있습니다.

### I/O 작업에 대한 결론
I/O 작업을 효과적으로 관리하는 것은 I/O 바운드 애플리케이션의 성능을 향상시키는 데 중요합니다. 적절한 블로킹 및 논블로킹 모델을 사용하여 리소스 사용을 최적화하고 시스템의 전반적인 성능을 향상시킬 수 있습니다.

## **자바에서 가상 스레드 소개**

### 자바 스레드와 OS 스레드의 관계
- **자바의 `Thread` 클래스**: OS 스레드 위에 추상화된 레이어를 제공합니다.

### 가상 스레드 설명
자바 15부터 도입된 프로젝트 로움의 일부인 가상 스레드는 기존 스레딩 모델의 한계를 극복하기 위해 설계되었습니다. 이 스레드는 [[Atlas/Ideas/JVM\|JVM]] 내에서 관리되며 OS 스레드를 직접 사용하지 않습니다.

### 가상 스레드 사용 예
```java
Thread.startVirtualThread(() -> {
    System.out.println("This is a virtual thread!");
});
```

### 가상 스레드의 이점
1. **경량성**: 메모리와 스케줄링 측면에서 매우 효율적입니다.
2. **성능 향상**: 수많은 동시 작업을 처리할 수 있어 I/O 바운드 애플리케이션의 성능이 크게 향상됩니다.
3. **간소화된 프로그래밍 모델**: 개발자는 OS 스레드 관리의 복잡성 없이 많은 스레드를 쉽게 사용할 수 있습니다.
## 궁금했던 점

### 실제 가상 스레드 사용 예시

가상 스레드는 다양한 서비스와 애플리케이션에서 사용되고 있습니다. 예를 들어, Spring Framework는 스프링 6.1 버전에서 JDK 21을 통해 가상 스레드를 사용하며, 이는 높은 동시성과 향상된 처리량을 제공합니다​ ([MangKyu's Diary](https://mangkyu.tistory.com/317))​. 또한, 자바 21의 가상 스레드는 서버 애플리케이션에서 요청당 스레드(request-per-thread) 방식을 더욱 효율적으로 실행할 수 있게 하여 하드웨어 자원의 낭비를 줄이고 처리량을 높일 수 있습니다​ ([알아두면 쓸만한 개발 잡학사전](https://devel-repository.tistory.com/67))​.
## OS Thread는 무엇인가

OS 스레드는 **운영 체제가 프로그램의 실행을 관리하기 위해 사용하는 기본적인 실행 단위**입니다. 각 스레드는 CPU 사용의 기본 단위로 독립적인 실행 흐름을 가지며, 별도의 스택, 프로그램 카운터, 그리고 일련의 레지스터 상태를 포함합니다.

- **자바와 OS 스레드**: 자바에서 `Thread` 클래스를 사용하여 스레드를 생성하면, 자바의 스레드 관리 시스템이 운영 체제의 스레드 관리 기능을 호출하여 실제 OS 스레드를 생성합니다. 이 과정에서 자바 스레드는 OS 스레드에 의존적이며, 자바 스레드의 생명주기와 자원은 그 OS 스레드에 결속됩니다.

- **OS 스레드의 역할**: OS 스레드는 다중 작업 처리의 기본을 형성하며, 운영 체제는 이러한 스레드를 스케줄링하여 여러 프로그램과 프로세스가 동시에 실행될 수 있도록 합니다. 각 스레드는 독립적인 작업 실행 흐름을 가지고 있어, 어플리케이션 내에서 병렬 처리가 가능하게 됩니다.

이러한 방식으로 자바는 `Thread` 클래스를 통해 개발자가 쉽게 멀티스레딩 환경을 구현할 수 있도록 지원하며, 복잡한 운영 체제 수준의 스레드 관리를 추상화하여 제공합니다. 이 추상화 덕분에 개발자는 OS의 특정적인 스레드 구현 세부사항을 신경 쓰지 않고 자바 프로그램을 구현할 수 있습니다.
## 해당 컨텐츠는 유데미로부터 강의 쿠폰을 제공받아 작성되었습니다