---
{"related":null,"tags":["개발/언어/Java","글또"],"aliases":null,"link":["https://www.udemy.com/course/java-multi-threading/learn/lecture/30800316?start=0#overview"],"persona":null,"index":null,"date_created":"2024-04-03","date_modified":"2024-04-12","dg-publish":true,"permalink":"/efforts/notes//java/","dgPassFrontmatter":true,"noteIcon":"1","created":"2023-12-17T14:36:40.066+09:00","updated":"2024-04-12T14:18:31.238+09:00"}
---

# Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기
- [Course: 【한글자막】 Java 멀티스레딩, 병행성 및 성능 최적화 - 전문가 되기 | Udemy](https://www.udemy.com/course/java-multi-threading/learn/lecture/30800316?start=0#overview)
- 5시간

## **Lock-Free Algorithms, Data Structures, and Techniques in Multithreading**

### 락(Lock)의 문제점
락은 오랜 기간 동안 소프트웨어 및 하드웨어 개발에서 큰 역할을 해왔습니다. 대부분의 병행성 문제는 락을 통해 해결할 수 있지만, 다음과 같은 여러 문제점이 존재합니다:

1. **데드락(Deadlock)**: 애플리케이션의 가장 큰 문제 중 하나로, 복잡한 데드락 탐지 및 해결 로직을 구현하지 않으면 해결하기 어렵습니다.
2. **락 소유 시간**: 하나의 스레드가 다른 스레드보다 락을 오래 소유할 경우, 다른 스레드의 작업 속도를 늦출 수 있습니다.
3. **우선순위 역전(Priority Inversion)**: 더 높은 우선순위를 가진 스레드가 더 낮은 우선순위의 스레드가 소유한 락을 기다리면서 발생합니다.
4. **스레드 중단**: 스레드가 락을 소유한 상태에서 예기치 않게 중단되는 경우, 다른 스레드가 무한히 대기하게 되는 문제가 발생할 수 있습니다.
5. **성능 오버헤드**: 락을 획득하기 위한 스레드 간의 경쟁은 성능 저하를 초래할 수 있습니다.

### Lock-Free 프로그래밍의 필요성
- Lock-Free 프로그래밍은 원자적(atomic) 연산을 활용하여, 단일 하드웨어 명령어로 실행될 수 있도록 보장함으로써, 락을 사용하지 않고도 스레드 안전성을 제공합니다.
- **원자적 연산**은 하드웨어 수준에서 지원되며, 락이 없어도 데이터 경쟁 없이 안전하게 데이터를 읽고 쓸 수 있습니다.

### Java의 Atomic 클래스
- Java에서는 `java.util.concurrent.atomic` 패키지를 통해 다양한 원자적 클래스를 제공합니다.
- 이들 클래스는 내부적으로 원자적 연산을 수행할 수 있도록 설계되어 있으며, `AtomicInteger`, `AtomicLong`, `AtomicReference` 등을 포함합니다.
- 예를 들어, `AtomicInteger`는 원자적으로 정수 값을 증감시키는 연산(`incrementAndGet`, `getAndIncrement`)을 제공합니다.

### Lock-Free 데이터 구조의 예
Lock-Free 스택을 구현해 볼 수 있습니다. 이는 `AtomicReference`를 사용하여 스택의 상단을 가리키는 헤드 포인터를 관리하고, `compareAndSet` 연산을 활용하여 스레드 안전하게 항목을 추가하거나 제거할 수 있습니다.

### 결론
Lock-Free 프로그래밍은 특히 고성능이 요구되는 환경에서 락을 사용하는 것보다 훨씬 높은 성능을 제공할 수 있습니다. 올바른 도구와 기술을 선택하는 것이 중요하며, Lock-Free 알고리즘과 데이터 구조는 효율적인 멀티 스레딩 프로그래밍을 위한 강력한 옵션입니다.

## **High-Performance Threading Models for I/O Operations**

- I/O 바운드 애플리케이션에 대한 개념을 소개하고 두 가지 실제 사례를 살펴보면서 이러한 프로그램의 성능을 최적화하는 방법을 설명

### I/O 바운드 작업의 특성

- I/O 바운드 애플리케이션은 주로 **데이터를 읽고 쓰는데 많은 시간을 소비하는 애플리케이션**을 말합니다.
- 이는 데이터베이스 쿼리, 파일 시스템 작업, 네트워크 통신 등 외부 자원과의 상호 작용을 포함합니다.

### CPU와 메모리 구조의 간략한 개요

컴퓨터의 기본 구성을 이해하는 것이 중요합니다:
- **[[Atlas/MAPS/⚙️ CPU\|⚙️ CPU]]** 는 매우 빠르게 데이터를 처리할 수 있으며, 메모리에 직접 접근할 수 있습니다.
- **I/O 장치** (예: 하드 드라이브, 네트워크 카드)는 외부 장치로, CPU가 직접 접근할 수 없습니다.

### I/O 작업의 특성

- **블로킹 I/O**: 작업을 요청하고 데이터가 준비될 때까지 스레드가 차단됩니다. 이는 CPU의 유휴 시간을 초래할 수 있습니다.
- **논블로킹 I/O**: 작업을 요청하고 즉시 제어권을 반환하여 CPU가 다른 작업을 계속할 수 있게 합니다. 데이터가 준비되면, 인터럽트가 발생하고 CPU는 결과를 처리합니다.

### 블로킹 대 논블로킹 I/O의 성능

- 블로킹 I/O는 간단하고 직관적인 코드를 가능하게 하지만, I/O 작업이 완료될 때까지 스레드를 차단하여 CPU 리소스를 낭비할 수 있습니다.
- 이는 특히 I/O 작업이 빈번하거나 지연이 큰 애플리케이션에서 문제가 될 수 있습니다.

논블로킹 I/O는 스레드가 차단되지 않도록 함으로써 CPU의 유휴 시간을 최소화하고, 결과적으로 애플리케이션의 응답성과 처리량을 향상시킬 수 있습니다.

### 실제 사례

1. **웹 서버**
	- 웹 서버는 대개 많은 수의 동시 연결을 처리해야 하므로 논블로킹 I/O 모델이 적합합니다.
	- 각 연결은 독립적으로 처리될 수 있으며, I/O 작업이 완료될 때까지 기다리지 않아도 됩니다.

2. **데이터베이스 애플리케이션**
	- 데이터베이스 액세스가 주요 병목 지점인 애플리케이션에서 논블로킹 I/O를 사용하면, 다수의 쿼리가 동시에 처리되면서 전반적인 성능이 향상될 수 있습니다.

### 결론
- I/O 바운드 애플리케이션의 성능을 최적화하려면, I/O 작업을 효율적으로 관리하는 것이 중요합니다. 블로킹과 논블로킹 I/O 모델을 적절히 활용하여, 리소스 사용을 최적화하고 시스템의 전반적인 성능을 향상시킬 수 있습니다.

## 가상 스레드

### 자바 스레드와 OS 스레드의 관계
- 자바에서 스레드를 생성할 때, 이는 실제로 운영체제의 스레드를 기반으로 작동합니다.
- 자바의 `Thread` 클래스는 OS 스레드 위에 추상화된 레이어를 제공하며, 자바 코드에서 스레드를 생성하고 관리할 수 있게 해 줍니다.
	- 자바 스레드가 실행되면 OS 스레드가 생성되고, 자바 스레드의 생명주기는 OS 스레드에 의존적입니다.

### 가상 스레드 소개
- 가상 스레드는 자바 15부터 도입된 프로젝트 로움(Loom)의 일부로, 기존 스레드 모델의 한계를 극복하기 위해 설계되었습니다.
	- 이들은 경량 스레드로, OS 스레드를 직접 사용하지 않고 [[Atlas/Ideas/JVM\|JVM]] 내에서 관리됩니다.
	- 가상 스레드의 주요 목적은 높은 수준의 동시성과 스케일을 제공하는 것이며, 기존의 "플랫폼 스레드"에 비해 훨씬 적은 리소스를 사용합니다.

### 가상 스레드의 작동 원리
가상 스레드는 JVM이 관리하는 스레드 풀을 사용하여 실행됩니다. 이 스레드 풀에는 제한된 수의 플랫폼 스레드가 포함되어 있으며, 가상 스레드는 이 플랫폼 스레드들에 동적으로 할당됩니다. 가상 스레드가 작업을 완료하면, 다시 스레드 풀로 반환되어 다른 가상 스레드의 작업을 수행할 수 있습니다. 이 과정은 매우 빠르고 경제적으로 이루어집니다.

### 가상 스레드 사용의 이점
1. **경량성**: 가상 스레드는 메모리와 스케줄링 측면에서 매우 효율적입니다.
2. **성능 향상**: 많은 수의 동시 작업을 처리할 수 있어, I/O 바운드 애플리케이션에서 성능이 크게 향상됩니다.
3. **간소화된 프로그래밍 모델**: 개발자는 OS 스레드를 직접 관리하는 복잡성 없이, 많은 수의 스레드를 손쉽게 사용할 수 있습니다.

### 가상 스레드의 예제
아래는 간단한 가상 스레드를 생성하고 실행하는 자바 코드 예제입니다:

```java
Thread.startVirtualThread(() -> {
    System.out.println("This is a virtual thread!");
});
```

이 코드는 가상 스레드를 생성하고, 간단한 메시지를 출력합니다. 가상 스레드의 실행은 플랫폼 스레드에 영향을 주지 않으며, 매우 빠르게 처리됩니다.

### 결론
- 가상 스레드는 자바 애플리케이션의 동시성과 성능을 크게 향상시킬 수 있는 강력한 도구입니다.
- 이들은 특히 네트워크 호출이나 데이터베이스 쿼리와 같이 I/O 작업이 많은 애플리케이션에서 유용합니다. 가상 스레드의 도입으로 자바 개발자들은 더 적은 리소스로 더 많은 작업을 처리할 수 있게 되었습니다.


## 성능 최적화

이번 강의에서는 멀티 스레드 애플리케이션의 성능 최적화에 초점을 맞추어 다룰 예정입니다. 성능 최적화를 이해하기 위해서는 먼저 '성능'이라는 용어의 정의부터 시작하는 것이 중요합니다. 성능은 다양한 시나리오와 용례에 따라 다르게 측정될 수 있으며, 오늘은 특히 '지연 시간'과 '처리량'이라는 두 가지 주요 성능 메트릭에 대해 깊이 있게 알아볼 것입니다.

### 성능 메트릭 소개
1. **지연 시간 (Latency)**: 작업 하나가 완료되는 데 걸리는 시간을 의미하며, 시간 단위로 측정됩니다.
2. **처리량 (Throughput)**: 일정 시간 동안 완료된 작업의 양으로 측정되며, '시간 단위당 작업'으로 정의됩니다.

### 성능 최적화 전략
- **멀티 스레드 활용**: 단일 작업을 여러 하위 작업으로 분할하여 병렬로 처리함으로써 지연 시간을 줄이고 처리량을 높일 수 있습니다.
- **실제 사례 분석**: 실제 멀티 스레드 프로그래밍 예를 통해 성능 향상 가능성과 한계를 학습합니다.

## 실습: 멀티 스레드 최적화
이론적 배경을 바탕으로 한 실습을 통해 지연 시간을 줄이는 다양한 방법을 경험해 보겠습니다. 실제 코드 예제를 사용하여, 하나의 큰 작업을 여러 개의 작은 작업으로 나누어 멀티 스레드로 처리하고, 이로 인해 성능이 어떻게 개선되는지 관찰할 것입니다.

## 예상 질문
- 멀티 스레드 프로그래밍에서 작업을 효율적으로 분할하는 방법은 무엇인가요?
- 지연 시간과 처리량 간의 상관관계는 어떻게 될까요?
- 멀티 스레드 최적화가 모든 유형의 작업에 적용 가능한가요?
## 운영 체제 기초
### 멀티 스레드의 필요성
- **응답성 (Concurrency):** 사용자 경험 향상을 위해 작업을 병렬로 처리하여 애플리케이션의 반응 시간을 단축합니다.
- **성능 (Parallelism):** 하나의 프로세스 내에서 여러 스레드를 동시에 실행시켜 컴퓨팅 자원을 효율적으로 사용합니다.
- **자원 공유:** 동일 프로세스 내의 스레드끼리 메모리 등의 자원을 공유하여 효율적인 자원 사용이 가능합니다.
- **비용 효율:** 프로세스보다 스레드의 생성 및 컨텍스트 스위칭 비용이 적어 자원 사용이 경제적입니다.

### 컨텍스트 스위치 ([[Context Switch\|Context Switch]])

- **정의:** CPU가 이전 스레드의 상태를 저장하고, 다음 스레드의 상태를 불러오는 과정입니다.
- **비용:** 스레드 전환 시간은 작업 처리 시간에 포함되어 성능 저하의 원인이 될 수 있습니다. 너무 자주 발생하면, 시스템은 작업 처리보다 전환에 더 많은 시간을 소비하게 되어 **[[thrashing\|thrashing]]** 현상이 발생할 수 있습니다.
### 스레드 스케줄링

- **다중 스레드 실행:** 하나의 CPU 코어가 여러 스레드를 번갈아 가며 실행하여 병렬 처리 효과를 낼 수 있습니다.
- **기아 현상 (Starvation):** 일부 스레드가 CPU 시간을 독점하면 다른 스레드가 실행되지 못하는 현상입니다.
- **시간 분할 (Time Slicing):** 운영체제는 시간을 일정한 단위로 나누어 각 스레드에 공평하게 할당합니다.

### 멀티 스레드 Vs. 멀티 프로세스

- **보안:** 프로세스 간 격리를 통해 보안성을 강화할 수 있습니다.
- **자원 공유:** 멀티 스레딩은 자원 공유를 통해 효율적인 프로그램 실행이 가능하나, 멀티 프로세싱은 독립된 메모리 공간에서 실행되어 자원 공유가 제한적입니다.
- **선택 기준:** 보안과 자원 공유 중 어떤 것이 더 중요한지에 따라 멀티 스레드와 멀티 프로세스 중 적합한 아키텍처를 선택해야 합니다.
## Thinking
- [[Calendar/Daily Notes/2024-04-03\|2024-04-03]] 11:43 리눅스는 우선순위 기반 알고리즘을 사용한다
