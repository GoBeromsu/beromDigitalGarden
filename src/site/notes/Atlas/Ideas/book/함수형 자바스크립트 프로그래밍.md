---
{"aliases":null,"link":null,"up":null,"persona":null,"index":null,"related":null,"created":"2024-03-17T14:34:38.538+09:00","tags":["독서/2024","독서","국내도서","IT모바일","프로그래밍언어","JavaScript/CGI"],"title":"함수형 자바스크립트 프로그래밍","author":"유인동","category":"국내도서","total_page":388,"publish_date":"2017-11-22","cover_url":"https://image.yes24.com/goods/56885507/XL","status":"inProgress","start_read_date":"2024-03-17","finish_read_date":"2024-03-17","my_rate":0,"book_note":null,"date_created":"2024-03-17","date_modified":"2024-03-17","dg-publish":true,"permalink":"/atlas/ideas/book//","dgPassFrontmatter":true,"noteIcon":"1","updated":"2024-03-17T15:08:59.525+09:00"}
---

# 함수형 자바스크립트 프로그래밍

## Intro
### - 함수형 프로그래밍은 매우 실용적이다
- [[Atlas/MAPS/⚙️ 객체 지향 프로그래밍\|⚙️ 객체 지향 프로그래밍]]에서는 데이터 형이 기준이 된다
	- 객체지향 프로그래밍은 데이터 형을 설계한 후 데이터 형에 맞는 메서드를 붙여가는 식이다
- [[Efforts/Notes/수업/함수형 프로그래밍\|함수형 프로그래밍]]은 로직이 기준이 된다
	- 함수로 로직을 설계한 후 로직에 맞는 데이터를 인자로 사용한다


- 함수형 프로그래밍은 함수 내부를 함수로 추상화한다
	- 각기 다르게 생긴 데이터 형을 더 많이 지원하기 위해서이다
	- 데이터가 user인지 post인지 중요하지 않다, 즉 아주 높은 다형성을 가진 하나의 함수를 만드는 방식이다
- 함수형 프로그래밍은 코드가 짧다
	- 함수는 혼자 존재하기에 아무렇게나 조합하면 된다

- 함수형 프로그래밍은 생명주기가 단순하다
	- 언제든지 어디서든지 사용하기가 쉽다
	- 함수는 언제 선언 되었는가, 어느 scope에서 선언 되었는가, 언제 실행 되었는가, 언제 실행 될 것인가만 중요하다

## 1장. 함수형 자바스크립트 소개
- 함수형 프로그래밍은 Side Effect를 최대한 멀리하고 조합성을 강조하는 프로그래밍 패러다임이다
	- ![[함수형 자바스크립트 프로그래밍.pdf#page=25&rect=125,233,461,340|함수형 자바스크립트 프로그래밍, p.25]]
### 1.1 함수형 프로그래밍 그거 먹는건가요?
![[함수형 자바스크립트 프로그래밍.pdf#page=26&rect=69,327,414,461|함수형 자바스크립트 프로그래밍, p.26]]
- 함수는 값으로 다뤄질 수 있다

![[함수형 자바스크립트 프로그래밍.pdf#page=27&rect=129,287,458,507|함수형 자바스크립트 프로그래밍, p.27]]
- 함수는 값을 리턴 할 수 있고, 함수는 값이 될 수 있다
- 위의 코드의 시사점
	- 값으로써의 함수
	- [[+ Encounters/클로저\|클로저]]를 이용한 함수형 자바스크립트 스타일 예시

- addMaker가 리턴한 익명 함수는 [[+ Encounters/클로저\|클로저]]가 되었다

## 1.2 함수형 자바스크립트의 실용성
- 절차 지향적으로 작성 된 코드를 함수형으로 변경하며 함수형 자바스크립트의 실용성을 알아보자

```javascript
var users = [
    { id: 1, name: "ID", age: 32 },
    { id: 2, name: "HA", age: 25 },
    { id: 3, name: "BJ", age: 32 },
    { id: 4, name: "PJ", age: 28 },
    { id: 5, name: "JE", age: 27 },
    { id: 6, name: "IM", age: 32 },
    { id: 7, name:"HI", age :24 }
];

var temp_users = [];
for (var i = 0, len = users.length; i < len; i++) {
    if (users[i].age < 30) temp_users.push(users[i]);
}
console.log(temp_users.length); // Expected output should be less than or equal to total users

var ages = [];
for (var i = 0, len = temp_users.length; i < len; i++) {
    ages.push(temp_users[i].age);
}
console.log(ages); // Expected output should be an array of ages

temp_users = [];
for (var i = 0, len = users.length; i < len; i++) {
    if (users[i].age >=30) temp_users.push(users[i]);
}
console.log(temp_users.length); // Expected output should be less than or equal to total users

var names = [];
for (var i =0, len= temp_users.length; i<len ;i++){
   names.push(temp_users[i].name);
}
console.log(names); // Expected output should be an array of names
```
- 위의 코드를 리팩토링 해보자
	- 나이가 30보다 작은 유저를 모은다
	- 모은 유저의 내부를 보며 나이를 집계한다
	- 나이가 30보다 같거나 큰 유저들을 모은다
		- 해당 유저들의 이름을 모은다


- 리팩토링 하기 까다로운 부분
	- 중복을 제거 할 때 30 부분은 변수로 변경 할 수 있지만, 다른 연산을 바꾸기 애매하다
	- ==함수를 활용하면 이런 부분까지도 쉽게 추상화 가능하다==
![[함수형 자바스크립트 프로그래밍.pdf#page=29&rect=131,124,462,314|함수형 자바스크립트 프로그래밍, p.29]]
- fileter 함수의 시사점
	- filter는 predicate가 무엇을 할지 모른다. 오직 결과에 의존한다
		- id를 조회 할 지, age를 조회 할 지
- 함수형 프로그래밍의 특징을 볼 수 있다
	- 이전 값의 상태를 변경하지 않고, 새로운 값을 만드는 식으로 값을 다룬다
	- 마지막에 new_list를 return 하는 것처럼!
![[함수형 자바스크립트 프로그래밍.pdf#page=30&rect=68,236,396,473|함수형 자바스크립트 프로그래밍, p.30]]
- filter 함수의 사용을 보면, 익명 함수를 입력 받는다
	- user의 나이에 따라 분기함으로써 코드가 짧아졌다, 재사용성도 높은 함수이다!

- 함수형 프로그래밍 관점에서 filter 
	- filter 함수의 로직은 외부나 내부의 어떤 상태 변화에도 의존하지 않는다
		- 오직 한 가지 로직만 가지고 있다
		- `list[i]`의 값을 변경하거나 list의 개수를 변경하는 코드가 없다
	- 만들어진 `new_list`는 이 함수 내부에서 만들어져서 외부의 어떠한 상황이나 상태와 무관하다
		- `new_list`가 완성 될 때까지 외부의 어떠한 접근도 할 수 없다
	- filter의 if는 predicate의 결과에만 의존한다
		- predicate에서도 값을 변경하지 않고, 판단하는 로직만 있다

- 절차 지향 프로그래밍에서는 위에서 아래로 내려가며 특정 변수의 값을 변경하며 로직을 만든다
- 객체 지향 프로그래밍에서는 객체들을 만들어 놓고 객체들 간의 협업을 통해 로직을 만든다
	- 이벤트 등으로 서로를 연결 한 후 상태의 변화를 감지하여 스스로 자신이 가진 값을 변경
	- 상대 메소드를 직접 실행하여 상태를 변경하는 식으로 프로그래밍을 한다
- [[Efforts/Notes/수업/함수형 프로그래밍\|함수형 프로그래밍]] 에서는 항상 동일하게 동작하는 함수를 만들고 보조 함수를 조합하는 식으로 로직을 완성한다
	- 내부에서 관리하고 있는 상태를 따로 두지 않고 넘겨진 인자에만 의존한다
	- 동일한 인자가 들어오면 항상 동일한 값을 리턴하도록 한다
		- ==보조 함수 또한 인자이다==
		- 보조 함수에서도 상태를 변경하지 않으면 보조 함수를 받은 함수는 항상 동일한 결과를 만드는 함수가 된다
- 객체 지향에서 Side Effect를 줄이는 방법
	- 이전 객체와 같은 상태를 지닌 새 객체를 만드는 식으로 부수 효과를 줄 일 수 있다
	- 하지만, 무수히 많고 각기 다른 종류로 나누어진 객체들을 복사하는 식으로 다루는 것은 운용이 어렵다
		- 객체지향과 어울리지도 않다
	- 자신의 상태르 메서드를 통해 변경하는 것은 객체지향의 단점이 아닌 방법론 그 자체이다
	- 반면, [[Efforts/Notes/수업/함수형 프로그래밍\|함수형 프로그래밍]]은 부수 효과를 최소화하는 것이 목표에 가깝다 ==즉 지향점의 차이이다==
### 1.2.4 map 함수
- 여기서부터 해야 하고, 재밌다!